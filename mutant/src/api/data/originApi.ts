import { fetchData, postData, getBackend, escapeSingleQuotes } from './fetchData';
import { selectData } from './genericApi'; // Used for fetching after update
import type { IFetchResponse, IPostResponse } from './fetchData';

/**
 * Створення, редагування, видалення origin (камери або відеореєстратора)
 * DB Schema:
 * id serial (PK)
 * point_id (FK <point>)
 * origin	text (AK) -- Unique textual identifier, assumed to be auto-generated by backend/DB
 * name text (user friendly name)
 * origin_type_id	int4		not null (FK <origin_type>)
 * credentials	jsonb		 (camera credentials)
 * is_enabled	bool		not null
 */

// Interface for an Origin (camera or NVR)
export interface Origin {
  id: number;           // Primary key (serial)
  point_id: number;     // FK to pcnt.point
  origin: string;       // Unique textual identifier (AK), auto-generated
  name: string;         // User-friendly name
  origin_type_id: number; // FK to pcnt.origin_type
  credentials?: object | null;  // Camera/NVR credentials (JSONB), optional
  is_enabled: boolean;  // Is this origin active?
}

// Interface for an Origin linked to a customer, from v_customer_origin
export interface CustomerOrigin extends Origin {
  customer_id: number;
  ref_id?: string | number | null; // ref_id from origin table
}

const ORIGIN_TABLE_NAME = 'pcnt.origin';

// Helper to format values for SQL literals, ensuring proper escaping
const formatSqlValue = (value: any): string => {
  if (value === null || value === undefined) {
    return 'NULL';
  }
  if (typeof value === 'string') {
    return `''${escapeSingleQuotes(value)}''`;
  }
  if (typeof value === 'number' || typeof value === 'boolean') {
    return String(value); // Numbers and booleans don't need quotes
  }
  if (typeof value === 'object') {
    // For JSONB, stringify the object and then treat it as a string literal for SQL
    return `''${escapeSingleQuotes(JSON.stringify(value))}''`;
  }
  // Fallback for any other types (should ideally be handled explicitly)
  console.warn(`[formatSqlValue] Unexpected type for value: ${value}, type: ${typeof value}. Converting to string.`);
  return `''${escapeSingleQuotes(String(value))}''`;
};

/**
 * Fetches origins, optionally filtered by point_id.
 * @param point_id Optional ID of the point to fetch origins for.
 * @returns A promise that resolves to an array of Origin objects.
 */
const getOrigins = async (point_id?: number): Promise<Origin[]> => {
  console.log(`[originApi] getOrigins called for point_id: ${point_id}`);
  try {
    const params: any = {
      from: ORIGIN_TABLE_NAME,
      fields: 'id, point_id, origin, name, origin_type_id, credentials, is_enabled',
      order: 'name',
    };
    if (point_id !== undefined) {
      params.where = { point_id };
    }

    const response: IFetchResponse = await fetchData(params);
    console.log(`[originApi getOrigins] response for point_id ${point_id}:`, response);
    // Ensure response is an array, fetchData should ideally guarantee this for select or return [] on error
    return Array.isArray(response) ? response as Origin[] : [];
  } catch (err) {
    console.error(`[originApi getOrigins] Error fetching origins for point_id ${point_id}:`, err);
    return [];
  }
};

/**
 * Data required to create an origin.
 * 'id' and 'origin' (textual identifier) are auto-generated.
 */
export type CreateOriginData = Pick<Origin, 'point_id' | 'name' | 'origin'| 'origin_type_id' | 'is_enabled'> & Partial<Pick<Origin, 'credentials'>>;

/**
 * Creates a new origin.
 * The 'id' (PK) and 'origin' (textual AK) fields are auto-generated by the database/backend.
 * @param data Object containing the details for the new origin.
 * @returns A promise that resolves to the newly created Origin object.
 */
const createOrigin = async (data: CreateOriginData): Promise<Origin> => {
  console.log('[originApi] createOrigin called with data:', data);

  if (!data || typeof data.point_id !== 'number' || !data.name || typeof data.origin_type_id !== 'number' || typeof data.is_enabled !== 'boolean') {
    const errorMsg = 'point_id, name, origin_type_id, and is_enabled are required to create an origin.';
    console.error(`[originApi] createOrigin validation failed: ${errorMsg}`);
    throw new Error(errorMsg);
  }

  const valuesToInsert = [
    data.point_id,
    formatSqlValue(data.name),
    formatSqlValue(data.origin),
    data.origin_type_id,
    data.credentials !== undefined ? formatSqlValue(data.credentials) : 'NULL',
    data.is_enabled,
  ];

  try {
    const result: IPostResponse = await postData({
      backend_point: getBackend().backend_point_insert,
      dest: ORIGIN_TABLE_NAME,
      fields: 'point_id, name, origin, origin_type_id, credentials, is_enabled',
      values: [valuesToInsert], // postData for insert expects array of arrays of formatted values
      returning: 'id',
      // returning: 'id, point_id, origin, name, origin_type_id, credentials, is_enabled',
    });

    if (result.ok && result.data && Array.isArray(result.data) && result.data.length > 0) {
      const newOrigin = result.data[0] as Origin;
      // if (typeof newOrigin.id !== 'number' || typeof newOrigin.origin !== 'string') {
      if (typeof newOrigin.id !== 'number') {
        console.error('[originApi] createOrigin: Insert successful, but returned data is malformed:', newOrigin);
        throw new Error('Failed to create origin: Backend returned invalid data (missing id or origin text).');
      }
      console.log('[originApi] createOrigin successful, new origin:', newOrigin);
      return newOrigin;
    } else {
      const errorMsg = (result as any).error || (result.ok ? 'Insert reported success, but no valid data returned.' : 'Failed to create origin.');
      console.error(`[originApi] createOrigin failed: ${errorMsg}`, result);
      throw new Error(errorMsg);
    }
  } catch (err: any) {
    console.error('[originApi] Error during createOrigin process:', err.message || err, err);
    throw err instanceof Error ? err : new Error(String(err.message || 'An unknown error occurred during origin creation.'));
  }
};

/**
 * Data required to update an origin. All fields are optional.
 * 'id' and 'origin' (textual identifier) cannot be changed via this method.
 */
export type UpdateOriginData = Partial<Omit<Origin, 'id' >>;

/**
 * Updates an existing origin.
 * @param id The ID of the origin to update.
 * @param data An object containing the fields to update.
 * @returns A promise that resolves to the updated Origin object.
 */
const updateOrigin = async (id: number, data: UpdateOriginData): Promise<Origin> => {
  console.log('[originApi] updateOrigin called for id:', id, 'with data:', data);

  if (Object.keys(data).length === 0) {
    console.warn('[originApi] updateOrigin: No data provided for update.');
    throw new Error('No data provided for origin update.');
  }

  const setClauses: string[] = [];
  // Explicitly iterate over known updatable fields to prevent attempting to update 'id'
  const updatableFields: (keyof UpdateOriginData)[] = ['point_id', 'name', 'origin', 'origin_type_id', 'credentials', 'is_enabled'];

  for (const key of updatableFields) {
    if (data.hasOwnProperty(key)) {
      const value = data[key];
      setClauses.push(`${key} = ${formatSqlValue(value)}`);
    }
  }

  if (setClauses.length === 0) {
    console.warn('[originApi] updateOrigin: No valid fields to update after processing data.');
    // This might happen if data contained only 'id' or 'origin', which are not updatable here.
    // Or if all values were undefined.
    // Fetch and return the current origin as no update is performed.
    const currentOrigins = await getOrigins(); // This fetches all, need to filter or use selectData
    const currentOrigin = currentOrigins.find(o => o.id === id);
    if (currentOrigin) return currentOrigin;
    throw new Error(`Origin with id ${id} not found, and no valid fields to update.`);
  }

  const updateQuery = `UPDATE ${ORIGIN_TABLE_NAME} SET ${setClauses.join(', ')} WHERE id = ${id}`;

  try {
    console.log('[originApi] updateOrigin query:', updateQuery);
    const result = await postData({
      backend_point: getBackend().backend_point_query,
      query: updateQuery,
    });

    if (result.ok) {
      const affectedRows = typeof result.data === 'number' ? result.data : (Array.isArray(result.data) && typeof result.data[0] === 'number' ? result.data[0] : -1);

      // Fetch the updated (or current) origin to return it
      const updatedOrigins = await selectData<Origin>({ // Using selectData for a clean fetch
        from: ORIGIN_TABLE_NAME,
        fields: 'id, point_id, origin, name, origin_type_id, credentials, is_enabled',
        where: { id },
      });

      if (updatedOrigins.length > 0) {
        console.log(`[originApi] updateOrigin for id ${id} completed. Affected rows: ${affectedRows}. Returning:`, updatedOrigins[0]);
        return updatedOrigins[0];
      }
      // This case means the origin was deleted between update and fetch, or ID never existed.
      throw new Error(`Origin with id ${id} not found after update attempt (affected ${affectedRows} rows).`);
    } else {
      const errorMsg = (result as any).error || 'Unknown backend error during origin update.';
      console.error(`[originApi] Update for origin id ${id} failed. Error: ${errorMsg}`, result);
      throw new Error(`Failed to update origin ${id}: ${errorMsg}`);
    }
  } catch (err: any) {
    console.error(`[originApi] Error during updateOrigin process for id ${id}:`, err.message || err, err);
    throw err instanceof Error ? err : new Error(String(err.message || `An unknown error occurred while updating origin ${id}.`));
  }
};

/**
 * Deletes an origin by its ID.
 * @param id The ID of the origin to delete.
 * @returns A promise that resolves to true if deletion was successful (affected rows > 0).
 */
const deleteOrigin = async (id: number): Promise<boolean> => {
  console.log('[originApi] deleteOrigin called for id:', id);
  const deleteQuery = `DELETE FROM ${ORIGIN_TABLE_NAME} WHERE id = ${id}`;

  try {
    const result = await postData({
      backend_point: getBackend().backend_point_query,
      query: deleteQuery,
    });

    if (result.ok) {
      const affectedRows = typeof result.data === 'number' ? result.data : (Array.isArray(result.data) && typeof result.data[0] === 'number' ? result.data[0] : -1);
      if (affectedRows > 0) {
        console.log(`[originApi] Origin with id ${id} deleted successfully.`);
        return true;
      } else {
        console.warn(`[originApi] No origin found with id ${id} to delete, or already deleted.`);
        return false;
      }
    } else {
      const errorMsg = (result as any).error || 'Unknown backend error during origin delete.';
      console.error(`[originApi] Delete for origin id ${id} failed. Error: ${errorMsg}`, result);
      throw new Error(`Failed to delete origin ${id}: ${errorMsg}`);
    }
  } catch (err: any) {
    console.error(`[originApi] Error during deleteOrigin process for id ${id}:`, err.message || err, err);
    throw err instanceof Error ? err : new Error(String(err.message || `An unknown error occurred while deleting origin ${id}.`));
  }
};

/**
 * Fetches all origins for a given customer_id from the v_customer_origin view.
 * @param customerId The ID of the customer.
 * @returns A promise that resolves to an array of CustomerOrigin objects.
 */
const getCustomerOrigins = async (customerId: number): Promise<CustomerOrigin[]> => {
  console.log(`[originApi] getCustomerOrigins called for customerId: ${customerId}`);
  const VIEW_NAME = 'v_customer_origin'; // As specified in the request
  try {
    const params = {
      from: VIEW_NAME,
      fields: 'customer_id, origin, id, point_id, ref_id, origin_type_id, credentials, is_enabled, name',
      where: { customer_id: customerId },
      order: 'name', // Optional: order by origin name
    };

    const response: IFetchResponse = await fetchData(params);
    console.log(`[originApi getCustomerOrigins] response for customerId ${customerId}:`, response);
    // Ensure response is an array
    if (Array.isArray(response)) {
      return response as CustomerOrigin[];
    }
    console.warn(`[originApi getCustomerOrigins] Expected array but received:`, response);
    return [];
  } catch (err) {
    console.error(`[originApi getCustomerOrigins] Error fetching origins for customerId ${customerId}:`, err);
    return [];
  }
};

export const originApi = {
  getOrigins,
  createOrigin,
  updateOrigin,
  deleteOrigin,
  getCustomerOrigins,
};