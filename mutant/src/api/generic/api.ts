// api.ts
import axios, { AxiosResponse, AxiosError, AxiosRequestConfig } from 'axios';

// Базовый URL для вашего API
// const API_BASE_URL = 'https://jsonplaceholder.typicode.com'; // Пример: используем JSONPlaceholder
// todo: заменить на ваш реальный URL
const API_BASE_URL = 'https://vca.theweb.place/back';

// Создаем экземпляр Axios с базовыми настройками
const axiosInstance = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000, // 10 секунд
});

// Интерцептор для обработки общих ошибок
axiosInstance.interceptors.response.use(
  (response: AxiosResponse) => response,
  (error: AxiosError) => {
    if (error.response) {
      // Сервер ответил с ошибкой статуса (4xx, 5xx)
      console.error('API Error:', error.response.status, error.response.data);
      // Здесь можно добавить более сложную логику обработки ошибок,
      // например, перенаправление на страницу входа при 401
      if (error.response.status === 401) {
        // window.location.href = '/login';
        alert('Unauthorized! Please log in again.');
      }
    } else if (error.request) {
      // Запрос был сделан, но ответа не получено (например, проблемы с сетью)
      console.error('Network Error:', error.request);
      alert('Network error. Please check your internet connection.');
    } else {
      // Что-то пошло не так при настройке запроса
      console.error('Request Error:', error.message);
      alert('An unexpected error occurred.');
    }
    return Promise.reject(error);
  }
);

// Тип для первичного ключа
type EntityId = string | number;

/**
 * Вспомогательная функция для удаления полей из объекта.
 * Используем дженерики для сохранения типов.
 */
function omit<T extends object, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {
  const newObj = { ...obj };
  for (const key of keys) {
    delete newObj[key];
  }
  return newObj as Omit<T, K>; // Assert the correct return type
}

export const api = {
  /**
   * Получение списка сущностей с возможностью передачи параметров запроса.
   *
   * @param endpoint Путь к ресурсу (например, '/posts', '/users')
   * @param params Опциональный объект с параметрами запроса, которые будут добавлены в URL как query string.
   * Например, `{ _limit: 10, _page: 1 }` превратится в `?_limit=10&_page=1`.
   * Примеры:
   * - `{ _limit: 10, _page: 1 }` (пагинация)
   * - `{ _sort: 'title', _order: 'asc' }` (сортировка по полю 'title' по возрастанию)
   * - `{ userId: 1 }` (фильтрация)   
   * @returns Promise с массивом сущностей
   */
  get: async <T>(
    endpoint: string,
    params?: Record<string, any>
  ): Promise<T[]> => {
    try {
      const config: AxiosRequestConfig = params ? { params } : {};
      const response: AxiosResponse<T[]> = await axiosInstance.get(endpoint, config);
      return response.data;
    } catch (error) {
      console.error(`Error fetching ${endpoint} with params ${JSON.stringify(params)}:`, error);
      throw error;
    }
  },
  /**
   * Отправка новой сущности.
   * Позволяет динамически исключать поля, которые должны быть сгенерированы сервером.
   *
   * @param endpoint Путь к ресурсу (например, '/posts')
   * @param data Данные новой сущности.
   * @param autoGeneratedKeys Опциональный массив ключей, которые должны быть исключены
   * из отправляемых данных, так как они генерируются сервером.
   * @returns Promise с созданной сущностью (уже со всеми полями, включая сгенерированные)
   */
  post: async <T extends { [key: string]: any }, K extends keyof T>(
    endpoint: string,
    data: Omit<T, K> | T, // Допустимо передавать как с исключенными полями, так и полный объект
    autoGeneratedKeys: K[] = [] as K[] // Safer default: omit no keys by default
  ): Promise<T> => {
    try {
      // Фильтруем данные, удаляя автогенерируемые поля
      // Cast 'data' to T. If data is Omit<T, K>, omit will still work correctly
      // as 'delete' on non-existent keys is a no-op.
      const dataToSend: Omit<T, K> = omit(data as T, autoGeneratedKeys);

      const response: AxiosResponse<T> = await axiosInstance.post(endpoint, dataToSend);
      return response.data; // Сервер возвращает полную сущность с ID
    } catch (error) {
      console.error(`Error posting to ${endpoint}:`, error);
      throw error;
    }
  },

  /**
   * A. Передача составного PK как параметров запроса (Query Parameters):
   * Этот подход наиболее распространён, когда PK составной. URL будет выглядеть примерно так: 
   * /resource?id1=value1&id2=value2.
   */

  /**
   * Обновление существующей сущности с возможностью составного PK через query параметры.
   *
   * @param endpoint Путь к ресурсу (например, '/order-items')
   * @param data Полный или частичный объект сущности для обновления.
   * @param compositePkParams Объект с полями, составляющими составной первичный ключ.
   * Например: { orderId: 1, itemId: 'A' }. Эти поля будут добавлены как query параметры.
   * @returns Promise с обновленной сущностью
   */
  put: async <T>(
    endpoint: string,
    data: Partial<T>,
    compositePkParams: Record<string, EntityId> // Объект для составного PK
  ): Promise<T> => {
    try {
      const config: AxiosRequestConfig = { params: compositePkParams }; // PK теперь в параметрах
      const response: AxiosResponse<T> = await axiosInstance.put(endpoint, data, config);
      return response.data;
    } catch (error) {
      console.error(`Error putting to ${endpoint} with composite PK ${JSON.stringify(compositePkParams)}:`, error);
      throw error;
    }
  },

  /**
   * Удаление сущности с возможностью составного PK через query параметры.
   *
   * @param endpoint Путь к ресурсу (например, '/order-items')
   * @param compositePkParams Объект с полями, составляющими составной первичный ключ.
   * Например: { orderId: 1, itemId: 'A' }. Эти поля будут добавлены как query параметры.
   * @returns Promise с данными об удалении
   */
  delete: async (
    endpoint: string,
    compositePkParams: Record<string, EntityId> // Объект для составного PK
  ): Promise<void> => {
    try {
      const config: AxiosRequestConfig = { params: compositePkParams }; // PK теперь в параметрах
      await axiosInstance.delete(endpoint, config);
      console.log(`Successfully deleted ${endpoint} with composite PK ${JSON.stringify(compositePkParams)}`);
    } catch (error) {
      console.error(`Error deleting ${endpoint} with composite PK ${JSON.stringify(compositePkParams)}:`, error);
      throw error;
    }
  },

};


